Chapter 01: Towards Modern C++

1.1 Deprecated Features ( If you don't know, don't even try to understand about that )

• The string literal constant is no longer allowed to be assigned to a char *. If you need to assign and initialize a char * with a string literal constant, you should use const char * or auto.

char *str = "hello world" -> string = "hello world" or const char *str = "hello world"

• C++98 exception description, unexpected_handler, set_unexpected() and other related features are deprecated and should use noexcept.

• auto_ptr is deprecated and unique_ptr should be used.

• register keyword is deprecated and can be used but no longer has any practical meaning.

• The ++ operation of the bool type is deprecated.

• If a class has a destructor, the properties for which it generates copy constructors and copy assignment operators are deprecated

• C language style type conversion is deprecated 

1.2 Compatibilities with C

You should have the idea that "C++ is not a superset of C" in your mind

When you have to use C, you should pay attention to the use of extern "C", separate the C language code from the C++ code

// foo.h
#ifdef __cplusplus
    extern "C" {
#endif

int add(int x, int y);

#ifdef __cplusplus
}
#endif

// foo.c
int add(int x, int y) 
{
    return x+y;
}

// 1.1.cpp
#include "foo.h"
#include <iostream>
#include <functional>
int main() 
{
    [out = std::ref(std::cout << "Result from C code: " << add(1, 2))]()
    {
        out.get() << ".\n";
    }();

    return 0;
}

Chapter 02: Language Usability Enhancements

2.1 Constants
- nullptr

  The purpose of nullptr appears to replace NULL

  C++ without the void * implicit conversion has to define NULL as 0. 

  Defining NULL to 0 will cause the overloading feature in C++ to be confusing.

// Source 
#include <iostream>
#include <type_traits>

void foo(char *);
void foo(int);

int main() 
{
    if (std::is_same<decltype(NULL), decltype(0)>::value)
    {
        std::cout << "NULL == 0" << std::endl;
    }

    if (std::is_same<decltype(NULL), decltype((void*)0)>::value)
    {
        std::cout << "NULL == (void *)0" << std::endl;
    }

    if (std::is_same<decltype(NULL), std::nullptr_t>::value)
    {
        std::cout << "NULL == nullptr" << std::endl;
    }

    foo(0); // will call foo(int)
    // foo(NULL); // doesn't compile
    foo(nullptr); // will call foo(char*)

    return 0;
}

void foo(char *) 
{
    std::cout << "foo(char*) is called" << std::endl;
}

void foo(int i) 
{
    std::cout << "foo(int) is called" << std::endl;
}

  The outputs are:

  foo(int) is called
  foo(char*) is called

- constexpr

  C++ itself already has the concept of constant expressions, such as 1+2, 3*4. 
  
  Such expressions always produce the same result without any side effects. 

  If the compiler can directly optimize and embed these expressions into the program at compile-time, it will increase the performance of the program.

  In addition, the function of constexpr can use recursion

#include <iostream>

#define LEN 10

int len_foo() 
{
    int i = 2;
    return i;
}

constexpr int len_foo_constexpr() 
{
    return 5;
}

constexpr int fibonacci(const int n) 
{
    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);
}

int main() 
{
    char arr_1[10]; // legal
    char arr_2[LEN]; // legal

    int len = 10;
    
    // char arr_3[len]; // illegal
    const int len_2 = len + 1;
    constexpr int len_2_constexpr = 1 + 2 + 3;

    // char arr_4[len_2]; // illegal, but ok for most of the compilers
    char arr_4[len_2_constexpr]; // legal

    // char arr_5[len_foo()+5]; // illegal
    char arr_6[len_foo_constexpr() + 1]; // legal
    
    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
    std::cout << fibonacci(10) << std::endl;

    return 0;
}

2.2 Variables and initialization

- if-switch

#include <iostream>
#include <vector>
#include <algorithm>

int main() 
{
    std::vector<int> vec = {1, 2, 3, 4};
    
    // since c++17, can be simplified by using `auto`
    const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2);

    if (itr != vec.end()) 
    {
        *itr = 3;
    }

    if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) 
    {
        *itr = 4;
    }

    // should output: 1, 4, 3, 4. can be simplified using `auto`
    for (std::vector<int>::iterator element = vec.begin(); element != vec.end(); ++element)

    std::cout << *element << std::endl;
}

- Initializer list
  Binds the concept of the initialization list to the type and calls it std::initializer_list, 
  allowing the constructor or other function to use the initialization list like a parameter

#include <initializer_list>
#include <vector>
#include <iostream>

class MagicFoo 
{
    public:
        std::vector<int> vec;

        MagicFoo(std::initializer_list<int> list) 
        {
            for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it)
            {
                vec.push_back(*it);
            }
        }
};

int main() 
{
    // after C++11
    MagicFoo magicFoo = {1, 2, 3, 4, 5};

    std::cout << "magicFoo: ";

    for (std::vector<int>::iterator it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it)
    {
        std::cout << *it << std::endl;
    }
}

- Structured binding
  Structured bindings provide functionality similar to the multiple return values

#include <iostream>
#include <tuple>

std::tuple<int, double, std::string> f() 
{
    return std::make_tuple(1, 2.3, "456");
}

int main() 
{
    auto [x, y, z] = f();

    std::cout << x << ", " << y << ", " << z << std::endl;

    return 0;
}

2.3 Type inference

C++11 introduces the two keywords auto and decltype to implement type derivation

- auto

#include <initializer_list>
#include <vector>
#include <iostream>

class MagicFoo 
{
    public:
        std::vector<int> vec;

        MagicFoo(std::initializer_list<int> list) 
        {
            for (auto it = list.begin(); it != list.end(); ++it) 
            {
                vec.push_back(*it);
            }
        }
};

int main() 
{
    MagicFoo magicFoo = {1, 2, 3, 4, 5};

    std::cout << "magicFoo: ";

    for (auto it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it) 
    {
        std::cout << *it << ", ";
    }
    
    std::cout << std::endl;

    return 0;
}

  Since C++ 20, auto can even be used as function arguments

int add(auto x, auto y) 
{
    return x+y;
}

auto i = 5; // type int
auto j = 6; // type int

std::cout << add(i, j) << std::endl;

- decltype
  Its usage is very similar to typeof:

auto x = 1;
auto y = 2;
decltype(x+y) z;

if (std::is_same<decltype(x), int>::value)
{
    std::cout << "type x == int" << std::endl;
}

if (std::is_same<decltype(x), float>::value)
{
    std::cout << "type x == float" << std::endl;
}

if (std::is_same<decltype(x), decltype(z)>::value)
{
    std::cout << "type z == type x" << std::endl;
}

output

type x == int
type z == type x

- tail type inference

  C++11 also introduces a trailing return type, which uses the auto keyword to post the return type:

template<typename T, typename U>
auto add2(T x, U y) -> decltype(x + y)
{
    return x + y;
}

  In C++14, it is possible to directly derive the return value of a normal function, so the following way becomes legal

template<typename T, typename U>
auto add3(T x, U y)
{
    return x + y;
}

// after c++11
auto w = add2<int, double>(1, 2.0);

if (std::is_same<decltype(w), double>::value) 
{
    std::cout << "w is double: ";
}

std::cout << w << std::endl;

// after c++14
auto q = add3<double, int>(1.0, 2);

std::cout << "q: " << q << std::endl;

- declytype(auto)

  It is mainly used to derive the return type of a forwarding function or package, 
  which does not require us to explicitly specify the parameter expression of decltype.

std::string lookup1();
std::string& lookup2();

// In C++11:
std::string look_up_a_string_1() 
{
    return lookup1();
}

std::string& look_up_a_string_2() 
{
    return lookup2();
}

// In C++14
decltype(auto) look_up_a_string_1() 
{
    return lookup1();
}

decltype(auto) look_up_a_string_2() 
{
    return lookup2();
}

2.4 Control flow

- if constexpr

  C++17 introduces the constexpr keyword into the if statement,
  allowing you to declare the condition of a constant expression in your code

// In code
#include <iostream>

template<typename T>
auto print_type_info(const T& t) 
{
    if constexpr (std::is_integral<T>::value) 
    {
        return t + 1;
    }
    else
    {
        return t + 0.001;
    }
}

int main() 
{
    std::cout << print_type_info(5) << std::endl;
    std::cout << print_type_info(3.14) << std::endl;
}

// At compile time
int print_type_info(const int& t) 
{
    return t + 1;
}

double print_type_info(const double& t) 
{
    return t + 0.001;
}

- Range-based for loop
  
#include <iostream>
#include <vector>
#include <algorithm>

int main() 
{
    std::vector<int> vec = {1, 2, 3, 4};

    if (auto itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end())
    {
        *itr = 4;
    }

    for (auto element : vec)
    {
        std::cout << element << std::endl; // read only
    }

    for (auto &element : vec) 
    {
        element += 1; // writeable
    }

    for (auto element : vec)
    {
        std::cout << element << std::endl; // read only
    }
}

2.5 Templates

The philosophy of the template is to throw all the problems that can be processed at compile time into the compile time, 
and only deal with those core dynamic services at runtime, to greatly optimize the performance of the runtime.

- Extern templates

  C++11 introduces an external template that extends the syntax of the original mandatory compiler to instantiate a template at a specific location, 
  allowing us to explicitly tell the compiler when to instantiate the template:

template class std::vector<bool>; // force instantiation
extern template class std::vector<double>; // should not instantiation in current file

- The">"

template<bool T>
class MagicType 
{
    bool magic = T;
};

int main()
{
    // legal, but not recommended
    std::vector<MagicType<(1>2)>> magic; 

    // ... 
}

- Type alias templates

  Templates are used to generate types.

  In traditional C++, typedef can define a new name for the type, but there is no way to define a new name for the template

  C++11 uses "using" to introduce the following form of writing, and at the same time supports the same effect as the traditional "typedef:"

typedef int (*process)(void *);
using NewProcess = int(*)(void *);

template<typename T>
using TrueDarkMagic = MagicType<std::vector<T>, std::string>;

int main() 
{
    TrueDarkMagic<bool> you;
}

- Variadic templates

  C++11 added a new representation, allowing any number, template parameters of any category, 
  and there is no need to fix the number of parameters when defining.

template<typename... Ts> class Magic;

class Magic<int, std::vector<int>, std::map<std::string, std::vector<int>>> darkMagic;

  a number of 0 is also possible

class Magic<>

  If you do not want to generate 0 template parameters, you can manually define at least one template parameter

template<typename Require, typename... Args> class Magic;

  The function parameters also use the same representation to represent the indefinite length parameters, 
  which provides a convenient means for us to simply write variable length parameter functions

  Also we can use sizeof... to calculate the number of arguments:

#include <iostream>

template<typename... Ts>
void magic(Ts... args) 
{
    std::cout << sizeof...(args) << std::endl;
}

  We can unpack the parameters with several methods

  1. Recursive template function

#include <iostream>

template<typename T0>
void printf1(T0 value) 
{
    std::cout << value << std::endl;
}

template<typename T, typename... Ts>
void printf1(T value, Ts... args) 
{
    std::cout << value << std::endl;
    printf1(args...);
}

int main() 
{
    printf1(1, 2, "123", 1.1);
    return 0;
}

  2. Variable parameter template expansion

template<typename T0, typename... T>
void printf2(T0 t0, T... t) 
{
    std::cout << t0 << std::endl;
    
    if constexpr (sizeof...(t) > 0)
    {
        printf2(t...);
    }
}

  3. Initialize list expansion

template<typename T, typename... Ts>
auto printf3(T value, Ts... args) 
{
    std::cout << value << std::endl;

    (void) std::initializer_list<T>{([&args] { std::cout << args << std::endl; }(), value)...};
}

- Fold expression

  In C++ 17, this feature of the variable length parameter is further brought to the expression

#include <iostream>

template<typename ... T>
auto sum(T ... t) 
{
    return (t + ...);
}

int main() 
{
    std::cout << sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) << std::endl;
}

- Non-type template parameter deduction

template <typename T, int BufSize>

class buffer_t 
{
    public:
        T& alloc();
        void free(T& item);
    
    private:
        T data[BufSize];
}

buffer_t<int, 100> buf; // 100 as template parameter

  Passing with a specific literal, can the compiler assist us in type derivation.
  In C++17, there is no longer a need to explicitly specify the type by using the placeholder "auto".

template <auto value> void foo() 
{
    std::cout << value << std::endl;
    return;
}

int main() 
{
    foo<10>(); // value as int
}

2.6 Object-oriented

- Delegate constructor

C++11 introduces the concept of a delegate construct, which allows a constructor to call another constructor in a constructor in the same class

#include <iostream>

class Base 
{
    public:
        int value1;
        int value2;
    
        Base() 
        {
            value1 = 1;
        }

        Base(int value) : Base() 
        { 
            // delegate Base() constructor
            value2 = value;
        }
};

int main() 
{
    Base b(2);
    std::cout << b.value1 << std::endl;
    std::cout << b.value2 << std::endl;
}

- Inheritance constructor

   C++11 introduces the concept of inheritance constructors "using" the keyword using:

#include <iostream>

class Base 
{
    public:
        int value1;
        int value2;

        Base() 
        {
            value1 = 1;
        }

        Base(int value) : Base()
        { 
            // delegate Base() constructor
            value2 = value;
        }
};

class Subclass : public Base 
{
    public:
        using Base::Base; // inheritance constructor
};

int main() 
{
    Subclass s(3);
    std::cout << s.value1 << std::endl;
    std::cout << s.value2 << std::endl;
}

- Explicit virtual function overwrite

  In traditional C++, it is often prone to accidentally overloading virtual functions.

  C++11 introduces the two keywords "override" and "final" to prevent this from happening

    1. override

    When overriding a virtual function, introducing the override keyword will explicitly tell the compiler to overload, 
    and the compiler will check if the base function has such a virtual function with consistent function signature, otherwise it will not compile:

struct Base 
{
    virtual void foo(int);
};

struct SubClass: Base 
{
    virtual void foo(int) override; // legal
    virtual void foo(float) override; // illegal, no virtual function in super class
};

    2. final
    "final" is to prevent the class from being continued to inherit and to terminate the virtual function to continue to be overloaded.

struct Base 
{
    virtual void foo() final;
};

struct SubClass1 final: Base {}; // legal
struct SubClass2 : SubClass1 {}; // illegal, SubClass1 has final
struct SubClass3: Base 
{
    void foo(); // illegal, foo has final
};

- Explicit delete default function

  The ability to accurately control the generation of default functions cannot be controlled.
  Also, the default constructor generated by the compiler cannot exist at the same time as the user-defined constructor. 

  C++11 allow explicit declarations to take or reject functions that come with the compiler

class Magic 
{
    public:
        Magic() = default; // explicit let compiler use default constructor
        Magic& operator=(const Magic&) = delete; // explicit declare refuse constructor
        Magic(int magic_number);
}

- Strongly typed enumerations
  
  In traditional C++, enumerated types are not type-safe, and enumerated types are treated as integers.

  C++11 introduces an enumeration class and declares it using the syntax of "enum class":

enum class new_enum : unsigned int 
{
    value1,
    value2,
    value3 = 100,
    value4 = 100
};

    1. It cannot be implicitly converted to an integer
    2. It cannot be compared to integer numbers
    3. It is even less likely to compare enumerated values of different enumerated types

  you can compare

if (new_enum::value3 == new_enum::value4) 
{ 
    std::cout << "new_enum::value3 == new_enum::value4" << std::endl;
}

We want to get the value of the enumeration value, we will have to explicitly type conversion,
but we can overload the << operator to output, you can collect the following code snippet:

#include <iostream>

template<typename T>
std::ostream& operator<<(typename std::enable_if<std::is_enum<T>::value, std::ostream>::type& stream, const T& e)
{
        return stream << static_cast<typename std::underlying_type<T>::type>(e);
}

Chapter 03: Language Runtime Enhancements

