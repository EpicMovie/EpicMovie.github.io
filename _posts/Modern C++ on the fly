Chapter 01: Towards Modern C++

1.1 Deprecated Features ( If you don't know, don't even try to understand about that )

• The string literal constant is no longer allowed to be assigned to a char *. If you need to assign and initialize a char * with a string literal constant, you should use const char * or auto.

char *str = "hello world" -> string = "hello world" or const char *str = "hello world"

• C++98 exception description, unexpected_handler, set_unexpected() and other related features are deprecated and should use noexcept.

• auto_ptr is deprecated and unique_ptr should be used.

• register keyword is deprecated and can be used but no longer has any practical meaning.

• The ++ operation of the bool type is deprecated.

• If a class has a destructor, the properties for which it generates copy constructors and copy assignment operators are deprecated

• C language style type conversion is deprecated 

1.2 Compatibilities with C

You should have the idea that "C++ is not a superset of C" in your mind

When you have to use C, you should pay attention to the use of extern "C", separate the C language code from the C++ code

// foo.h
#ifdef __cplusplus
    extern "C" {
#endif

int add(int x, int y);

#ifdef __cplusplus
}
#endif

// foo.c
int add(int x, int y) 
{
    return x+y;
}

// 1.1.cpp
#include "foo.h"
#include <iostream>
#include <functional>
int main() 
{
    [out = std::ref(std::cout << "Result from C code: " << add(1, 2))]()
    {
        out.get() << ".\n";
    }();

    return 0;
}

Chapter 02: Language Usability Enhancements

2.1 Constants
- nullptr

  The purpose of nullptr appears to replace NULL

  C++ without the void * implicit conversion has to define NULL as 0. 

  Defining NULL to 0 will cause the overloading feature in C++ to be confusing.

// Source 
#include <iostream>
#include <type_traits>

void foo(char *);
void foo(int);

int main() 
{
    if (std::is_same<decltype(NULL), decltype(0)>::value)
    {
        std::cout << "NULL == 0" << std::endl;
    }

    if (std::is_same<decltype(NULL), decltype((void*)0)>::value)
    {
        std::cout << "NULL == (void *)0" << std::endl;
    }

    if (std::is_same<decltype(NULL), std::nullptr_t>::value)
    {
        std::cout << "NULL == nullptr" << std::endl;
    }

    foo(0); // will call foo(int)
    // foo(NULL); // doesn't compile
    foo(nullptr); // will call foo(char*)

    return 0;
}

void foo(char *) 
{
    std::cout << "foo(char*) is called" << std::endl;
}

void foo(int i) 
{
    std::cout << "foo(int) is called" << std::endl;
}

  The outputs are:

  foo(int) is called
  foo(char*) is called

- constexpr

  C++ itself already has the concept of constant expressions, such as 1+2, 3*4. 
  
  Such expressions always produce the same result without any side effects. 

  If the compiler can directly optimize and embed these expressions into the program at compile-time, it will increase the performance of the program.

  In addition, the function of constexpr can use recursion

#include <iostream>

#define LEN 10

int len_foo() 
{
    int i = 2;
    return i;
}

constexpr int len_foo_constexpr() 
{
    return 5;
}

constexpr int fibonacci(const int n) 
{
    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);
}

int main() 
{
    char arr_1[10]; // legal
    char arr_2[LEN]; // legal

    int len = 10;
    
    // char arr_3[len]; // illegal
    const int len_2 = len + 1;
    constexpr int len_2_constexpr = 1 + 2 + 3;

    // char arr_4[len_2]; // illegal, but ok for most of the compilers
    char arr_4[len_2_constexpr]; // legal

    // char arr_5[len_foo()+5]; // illegal
    char arr_6[len_foo_constexpr() + 1]; // legal
    
    // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
    std::cout << fibonacci(10) << std::endl;

    return 0;
}

2.2 Variables and initialization

- if-switch

#include <iostream>
#include <vector>
#include <algorithm>

int main() 
{
    std::vector<int> vec = {1, 2, 3, 4};
    
    // since c++17, can be simplified by using `auto`
    const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2);

    if (itr != vec.end()) 
    {
        *itr = 3;
    }

    if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) 
    {
        *itr = 4;
    }

    // should output: 1, 4, 3, 4. can be simplified using `auto`
    for (std::vector<int>::iterator element = vec.begin(); element != vec.end(); ++element)

    std::cout << *element << std::endl;
}

- Initializer list
  Binds the concept of the initialization list to the type and calls it std::initializer_list, 
  allowing the constructor or other function to use the initialization list like a parameter

#include <initializer_list>
#include <vector>
#include <iostream>

class MagicFoo 
{
    public:
        std::vector<int> vec;

        MagicFoo(std::initializer_list<int> list) 
        {
            for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it)
            {
                vec.push_back(*it);
            }
        }
};

int main() 
{
    // after C++11
    MagicFoo magicFoo = {1, 2, 3, 4, 5};

    std::cout << "magicFoo: ";

    for (std::vector<int>::iterator it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it)
    {
        std::cout << *it << std::endl;
    }
}

- Structured binding
  Structured bindings provide functionality similar to the multiple return values

#include <iostream>
#include <tuple>

std::tuple<int, double, std::string> f() 
{
    return std::make_tuple(1, 2.3, "456");
}

int main() 
{
    auto [x, y, z] = f();

    std::cout << x << ", " << y << ", " << z << std::endl;

    return 0;
}

2.3 Type inference

C++11 introduces the two keywords auto and decltype to implement type derivation

- auto

#include <initializer_list>
#include <vector>
#include <iostream>

class MagicFoo 
{
    public:
        std::vector<int> vec;

        MagicFoo(std::initializer_list<int> list) 
        {
            for (auto it = list.begin(); it != list.end(); ++it) 
            {
                vec.push_back(*it);
            }
        }
};

int main() 
{
    MagicFoo magicFoo = {1, 2, 3, 4, 5};

    std::cout << "magicFoo: ";

    for (auto it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it) 
    {
        std::cout << *it << ", ";
    }
    
    std::cout << std::endl;

    return 0;
}

  Since C++ 20, auto can even be used as function arguments

int add(auto x, auto y) 
{
    return x+y;
}

auto i = 5; // type int
auto j = 6; // type int

std::cout << add(i, j) << std::endl;

- decltype
  Its usage is very similar to typeof:

auto x = 1;
auto y = 2;
decltype(x+y) z;

if (std::is_same<decltype(x), int>::value)
{
    std::cout << "type x == int" << std::endl;
}

if (std::is_same<decltype(x), float>::value)
{
    std::cout << "type x == float" << std::endl;
}

if (std::is_same<decltype(x), decltype(z)>::value)
{
    std::cout << "type z == type x" << std::endl;
}

output

type x == int
type z == type x

- tail type inference

  C++11 also introduces a trailing return type, which uses the auto keyword to post the return type:

template<typename T, typename U>
auto add2(T x, U y) -> decltype(x + y)
{
    return x + y;
}

  In C++14, it is possible to directly derive the return value of a normal function, so the following way becomes legal

template<typename T, typename U>
auto add3(T x, U y)
{
    return x + y;
}

// after c++11
auto w = add2<int, double>(1, 2.0);

if (std::is_same<decltype(w), double>::value) 
{
    std::cout << "w is double: ";
}

std::cout << w << std::endl;

// after c++14
auto q = add3<double, int>(1.0, 2);

std::cout << "q: " << q << std::endl;

- declytype(auto)

  It is mainly used to derive the return type of a forwarding function or package, 
  which does not require us to explicitly specify the parameter expression of decltype.

std::string lookup1();
std::string& lookup2();

// In C++11:
std::string look_up_a_string_1() 
{
    return lookup1();
}

std::string& look_up_a_string_2() 
{
    return lookup2();
}

// In C++14
decltype(auto) look_up_a_string_1() 
{
    return lookup1();
}

decltype(auto) look_up_a_string_2() 
{
    return lookup2();
}

2.4 Control flow

- if constexpr

  C++17 introduces the constexpr keyword into the if statement,
  allowing you to declare the condition of a constant expression in your code

// In code
#include <iostream>

template<typename T>
auto print_type_info(const T& t) 
{
    if constexpr (std::is_integral<T>::value) 
    {
        return t + 1;
    }
    else
    {
        return t + 0.001;
    }
}

int main() 
{
    std::cout << print_type_info(5) << std::endl;
    std::cout << print_type_info(3.14) << std::endl;
}

// At compile time
int print_type_info(const int& t) 
{
    return t + 1;
}

double print_type_info(const double& t) 
{
    return t + 0.001;
}

- Range-based for loop
  
#include <iostream>
#include <vector>
#include <algorithm>

int main() 
{
    std::vector<int> vec = {1, 2, 3, 4};

    if (auto itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end())
    {
        *itr = 4;
    }

    for (auto element : vec)
    {
        std::cout << element << std::endl; // read only
    }

    for (auto &element : vec) 
    {
        element += 1; // writeable
    }

    for (auto element : vec)
    {
        std::cout << element << std::endl; // read only
    }
}

2.5 Templates

The philosophy of the template is to throw all the problems that can be processed at compile time into the compile time, 
and only deal with those core dynamic services at runtime, to greatly optimize the performance of the runtime.

- Extern templates

  C++11 introduces an external template that extends the syntax of the original mandatory compiler to instantiate a template at a specific location, 
  allowing us to explicitly tell the compiler when to instantiate the template:

template class std::vector<bool>; // force instantiation
extern template class std::vector<double>; // should not instantiation in current file

- The">"

template<bool T>
class MagicType 
{
    bool magic = T;
};

int main()
{
    // legal, but not recommended
    std::vector<MagicType<(1>2)>> magic; 

    // ... 
}

- Type alias templates

  Templates are used to generate types.

  In traditional C++, typedef can define a new name for the type, but there is no way to define a new name for the template

  C++11 uses "using" to introduce the following form of writing, and at the same time supports the same effect as the traditional "typedef:"

typedef int (*process)(void *);
using NewProcess = int(*)(void *);

template<typename T>
using TrueDarkMagic = MagicType<std::vector<T>, std::string>;

int main() 
{
    TrueDarkMagic<bool> you;
}

- Variadic templates

  C++11 added a new representation, allowing any number, template parameters of any category, 
  and there is no need to fix the number of parameters when defining.

template<typename... Ts> class Magic;

class Magic<int, std::vector<int>, std::map<std::string, std::vector<int>>> darkMagic;

  a number of 0 is also possible

class Magic<>

  If you do not want to generate 0 template parameters, you can manually define at least one template parameter

template<typename Require, typename... Args> class Magic;

  The function parameters also use the same representation to represent the indefinite length parameters, 
  which provides a convenient means for us to simply write variable length parameter functions

  Also we can use sizeof... to calculate the number of arguments:

#include <iostream>

template<typename... Ts>
void magic(Ts... args) 
{
    std::cout << sizeof...(args) << std::endl;
}

  We can unpack the parameters with several methods

  1. Recursive template function

#include <iostream>

template<typename T0>
void printf1(T0 value) 
{
    std::cout << value << std::endl;
}

template<typename T, typename... Ts>
void printf1(T value, Ts... args) 
{
    std::cout << value << std::endl;
    printf1(args...);
}

int main() 
{
    printf1(1, 2, "123", 1.1);
    return 0;
}

  2. Variable parameter template expansion

template<typename T0, typename... T>
void printf2(T0 t0, T... t) 
{
    std::cout << t0 << std::endl;
    
    if constexpr (sizeof...(t) > 0)
    {
        printf2(t...);
    }
}

  3. Initialize list expansion

template<typename T, typename... Ts>
auto printf3(T value, Ts... args) 
{
    std::cout << value << std::endl;

    (void) std::initializer_list<T>{([&args] { std::cout << args << std::endl; }(), value)...};
}

- Fold expression

  In C++ 17, this feature of the variable length parameter is further brought to the expression

#include <iostream>

template<typename ... T>
auto sum(T ... t) 
{
    return (t + ...);
}

int main() 
{
    std::cout << sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) << std::endl;
}

- Non-type template parameter deduction

template <typename T, int BufSize>
class buffer_t 
{
    public:
        T& alloc();
        void free(T& item);
    
    private:
        T data[BufSize];
}

buffer_t<int, 100> buf; // 100 as template parameter

  Passing with a specific literal, can the compiler assist us in type derivation.
  In C++17, there is no longer a need to explicitly specify the type by using the placeholder "auto".

template <auto value> 
void foo() 
{
    std::cout << value << std::endl;
    return;
}

int main() 
{
    foo<10>(); // value as int
}

2.6 Object-oriented

- Delegate constructor

C++11 introduces the concept of a delegate construct, which allows a constructor to call another constructor in a constructor in the same class

#include <iostream>

class Base 
{
    public:
        int value1;
        int value2;
    
        Base() 
        {
            value1 = 1;
        }

        Base(int value) : Base() 
        { 
            // delegate Base() constructor
            value2 = value;
        }
};

int main() 
{
    Base b(2);
    std::cout << b.value1 << std::endl;
    std::cout << b.value2 << std::endl;
}

- Inheritance constructor

   C++11 introduces the concept of inheritance constructors "using" the keyword using:

#include <iostream>

class Base 
{
    public:
        int value1;
        int value2;

        Base() 
        {
            value1 = 1;
        }

        Base(int value) : Base()
        { 
            // delegate Base() constructor
            value2 = value;
        }
};

class Subclass : public Base 
{
    public:
        using Base::Base; // inheritance constructor
};

int main() 
{
    Subclass s(3);
    std::cout << s.value1 << std::endl;
    std::cout << s.value2 << std::endl;
}

- Explicit virtual function overwrite

  In traditional C++, it is often prone to accidentally overloading virtual functions.

  C++11 introduces the two keywords "override" and "final" to prevent this from happening

    1. override

    When overriding a virtual function, introducing the override keyword will explicitly tell the compiler to overload, 
    and the compiler will check if the base function has such a virtual function with consistent function signature, otherwise it will not compile:

struct Base 
{
    virtual void foo(int);
};

struct SubClass: Base 
{
    virtual void foo(int) override; // legal
    virtual void foo(float) override; // illegal, no virtual function in super class
};

    2. final
    "final" is to prevent the class from being continued to inherit and to terminate the virtual function to continue to be overloaded.

struct Base 
{
    virtual void foo() final;
};

struct SubClass1 final: Base {}; // legal
struct SubClass2 : SubClass1 {}; // illegal, SubClass1 has final
struct SubClass3: Base 
{
    void foo(); // illegal, foo has final
};

- Explicit delete default function

  The ability to accurately control the generation of default functions cannot be controlled.
  Also, the default constructor generated by the compiler cannot exist at the same time as the user-defined constructor. 

  C++11 allow explicit declarations to take or reject functions that come with the compiler

class Magic 
{
    public:
        Magic() = default; // explicit let compiler use default constructor
        Magic& operator=(const Magic&) = delete; // explicit declare refuse constructor
        Magic(int magic_number);
}

- Strongly typed enumerations
  
  In traditional C++, enumerated types are not type-safe, and enumerated types are treated as integers.

  C++11 introduces an enumeration class and declares it using the syntax of "enum class":

enum class new_enum : unsigned int 
{
    value1,
    value2,
    value3 = 100,
    value4 = 100
};

    1. It cannot be implicitly converted to an integer
    2. It cannot be compared to integer numbers
    3. It is even less likely to compare enumerated values of different enumerated types

  you can compare

if (new_enum::value3 == new_enum::value4) 
{ 
    std::cout << "new_enum::value3 == new_enum::value4" << std::endl;
}

We want to get the value of the enumeration value, we will have to explicitly type conversion,
but we can overload the << operator to output, you can collect the following code snippet:

#include <iostream>

template<typename T>
std::ostream& operator<<(typename std::enable_if<std::is_enum<T>::value, std::ostream>::type& stream, const T& e)
{
        return stream << static_cast<typename std::underlying_type<T>::type>(e);
}

Chapter 03: Language Runtime Enhancements

3.1 Lambda Expression

Lambda expressions provide a feature like anonymous functions.

Anonymous functions are used when a function is needed, but you don’t want to use a name to call a function.

- Basics

[capture list] (parameter list) mutable(optional) exception attribute -> return type 
{
    // function body
}

  The capture list can serve to transfer external data and can be divided into several types

    1. Value capture

    Similar to parameter passing, the value capture is based on the fact that the variable can be copied, 
    except that the captured variable is copied when the lambda expression is created, not when it is called

void lambda_value_capture() 
{
    int value = 1;
    auto copy_value = [value] 
    {
        return value;
    };

    value = 100;

    auto stored_value = copy_value();

    // At this moment, stored_value == 1, and value == 100.
    // Because copy_value has copied when its was created.
    std::cout << "stored_value = " << stored_value << std::endl;
}

    2. Reference capture

    Similar to a reference pass, the reference capture saves the reference and the value changes.

void lambda_reference_capture() 
{
    int value = 1;
    auto copy_value = [&value] 
    {
        return value;
    };
    value = 100;

    auto stored_value = copy_value();

    // At this moment, stored_value == 100, value == 100.
    // Because copy_value stores reference
    std::cout << "stored_value = " << stored_value << std::endl;
}

    3. Implicit capture

    • [] empty capture list
    • [name1, name2, …] captures a series of variables
    • [&] reference capture, let the compiler deduce the reference list by itself
    • [=] value capture, let the compiler deduce the value list by itself

    4. Expression capture

    C++14 gives us the convenience of allowing the captured members to be initialized with arbitrary expressions, 
    which allows the capture of rvalues

#include <iostream>
#include <memory> // std::make_unique
#include <utility> // std::move

void lambda_expression_capture() 
{
    auto important = std::make_unique<int>(1);
    auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int 
    {
        return x + y + v1 + (*v2);
    };
    
    std::cout << add(3,4) << std::endl;
}

    5. Generic Lambda

    In C++14, the formal parameters of the lambda function can use the auto keyword to utilize template generics.

void lambda_generic() 
{
    auto generic = [](auto x, auto y) 
    {
        return x+y;
    };

    std::cout << generic(1, 2) << std::endl;
    std::cout << generic(1.1, 2.2) << std::endl;
}
    
3.2 Function Object Wrapper

- std::function

  The essence of a Lambda expression is an object of a class type (called a closure type) that is similar to a function object type (called a closure object). 
  
  When the capture list of a Lambda expression is empty, the closure object can also be converted to a function pointer value for delivery.

#include <iostream>

using foo = void(int); // function pointer, Lambda as a function type

void functional(foo f) 
{
    f(1);
}

int main() 
{
    auto f = [](int value) 
    {
        std::cout << value << std::endl;
    };

    functional(f); // call by function pointer
    f(1);          // call by lambda expression

    return 0;
}

  In C++11, these concepts are unified. 
  The type of object that can be called is collectively called the callable type. 
  This type is introduced by "std::function".

  std::function is a generic, polymorphic function wrapper whose instances can store, copy, and call any target entity that can be called. 
  It is also an existing callable to C++.
  A type-safe package of entities (relatively, the call to a function pointer is not type-safe), in other words, a container of functions.

#include <functional>
#include <iostream>

int foo(int param) 
{
    return param;
}

int main() 
{
    // std::function wraps a function that take int paremeter and returns int value
    std::function<int(int)> func = foo;

    int important = 10;

    std::function<int(int)> func2 = [&](int value) -> int 
    {
        return 1 + value + important;
    };

    std::cout << func(10) << std::endl;
    std::cout << func2(10) << std::endl;
}

- std::bind and std::placeholder

  std::bind is used to bind the parameters of the function call.

int foo(int a, int b, int c) 
{
    return a + b + c;
}

int main() 
{
    // bind parameter 1, 2 on function foo,
    // and use std::placeholders::_1 as placeholder for the first parameter.
    auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2);

    // when call bindFoo, we only need one param left
    bindFoo(1);
}

3.3 rvalue Reference

- lvalue, rvalue, prvalue, xvalue

    1. lvalue ( left value )
    The value to the left of the assignment symbol. To be precise, an lvalue is a persistent object that still exists after and expression.

    2. Rvalue ( right value )
    The value on the right refers to the temporary object that no longer exists after the expression ends.

    The concpet of rvalue is further divided into two : prvalue and xvalue

      i) prvalue ( pure rvalue )
        (1) Purely literal such as 10 or true
        (2) The result of the evaluation that is equivalent to a literal or anonymous temporary object like 1 + 2
        (3) Temporary variables returned by non-references
        (4) Temporary variables generated by operation expressions, original literals, and lambda expressions

      Note that a literal (except a string literal) is a prvalue. However, a string literal is an lvalue with type const char array.

#include <type_traits>

int main() 
{
    // Correct. The type of "01234" is const char [6], so it is an lvalue
    const char (&left)[6] = "01234";

    // Assert success. It is a const char [6] indeed. Note that decltype(expr)
    // yields lvalue reference if expr is an lvalue and neither an unparenthesized
    // id-expression nor an unparenthesized class member access expression.
    static_assert(std::is_same<decltype("01234"), const char(&)[6]>::value, "");
    
    // Error. "01234" is an lvalue, which cannot be referenced by an rvalue reference
    // const char (&&right)[6] = "01234";
}

const char* p = "01234";    // Correct. "01234" is implicitly converted to const char*
const char*&& pr = "01234"; // Correct. "01234" is implicitly converted to const char*, which is a
const char*& pl = "01234";  // Error. There is no type const char* lvalue

      i) xvalue ( expiring value )
      a value that is destroyed but can be moved.

std::vector<int> foo() 
{
    std::vector<int> temp = {1, 2, 3, 4};
    return temp;
}

int main()
{
    std::vector<int> v = foo(); // Entire temp is copied to v and destroied ( a large overhead )
    // ...
}

      The return value generated by foo() is used as a temporary value. 

      Once copied by v, it will be destroyed immediately, and cannot be obtained or modified.
    
      The xvalue defines behavior in which temporary values can be identified while being able to be moved.

      After C++11, the compiler did some work for us, where the lvalue temp is subjected to this implicit rvalue conversion, 
      equivalent to static_cast<std::vector<int> &&>(temp), where v here moves the value returned by foo locally.

- rvalue reference and lvalue reference

  To get a xvalue, you need to use the declaration of the rvalue reference: T &&, where T is the type.

  The statement of the rvalue reference extends the lifecycle of this temporary value, 
  and as long as the variable is alive,
  the xvalue will continue to survive.

  C++11 provides the std::move method to unconditionally convert lvalue parameters to rvalues.

#include <iostream>
#include <string>

void reference(std::string& str) 
{
    std::cout << "lvalue" << std::endl;
}

void reference(std::string&& str) 
{
    std::cout << "rvalue" << std::endl;
}

int main()
{
    std::string lv1 = "string,"; // lv1 is a lvalue
    // std::string&& r1 = lv1; // illegal, rvalue can't ref to lvalue
    std::string&& rv1 = std::move(lv1); // legal, std::move can convert lvalue to rvalue
    
    std::cout << rv1 << std::endl; // string,

    const std::string& lv2 = lv1 + lv1; // legal, const lvalue reference can extend temp variable's lifecycle

    // lv2 += "Test"; // illegal, const ref can't be modified
    std::cout << lv2 << std::endl; // string,string,
    std::string&& rv2 = lv1 + lv2; // legal, rvalue ref extend lifecycle

    rv2 += "string"; // legal, non-const reference can be modified

    std::cout << rv2 << std::endl; // string,string,string,string
    reference(rv2); // output: lvalue

    return 0;
}

  rv2 refers to an rvalue, but since it is a reference, rv2 is still an lvalue.

#include <iostream>
int main() 
{
    // int &a = std::move(1); // illegal, non-const lvalue reference cannot ref rvalue
    const int &b = std::move(1); // legal, const lvalue reference can
    std::cout << b << std::endl;
}

  The first question, why not allow non-constant references to bind to non-lvalues? 

  This is because there is a logic error in this approach:

void increase(int & v) 
{
    v++;
}

void foo() 
{
    double s = 1;
    increase(s);
}

  Since int& can’t reference a parameter of type double, you must generate a temporary value to hold the value of s.
  Thus, when increase() modifies this temporary value, s itself is not modified after the call is completed.

  The second question, why do constant references allow binding to non-lvalues? The reason is simple because Fortran needs it.

- Move semantics

  Traditional C++ does not distinguish between the concepts of “mobile” and “copy”, resulting in a large amount of data copying, wasting time and space.

  The appearance of rvalue references solves the confusion of these two concepts

#include <iostream>

class A 
{
    public:
        int *pointer;

        A() : pointer(new int(1)) 
        {
            std::cout << "construct" << pointer << std::endl;
        }

        A(A& a) : pointer(new int(*a.pointer)) 
        {
            std::cout << "copy" << pointer << std::endl;
        }

        // meaningless object copy
        A(A&& a) : pointer(a.pointer) 
        {
            a.pointer = nullptr;
            std::cout << "move" << pointer << std::endl;
        }
        
        ~A()
        {
            std::cout << "destruct" << pointer << std::endl;
            delete pointer;
        }
};

// avoid compiler optimization
A return_rvalue(bool test) 
{
    A a,b;
    
    if(test) 
    {
        return a; // equal to static_cast<A&&>(a);
    }
    else
    {
        return b; // equal to static_cast<A&&>(b);
    }
}

int main() 
{
    A obj = return_rvalue(false);

    std::cout << "obj:" << std::endl;
    std::cout << obj.pointer << std::endl;
    std::cout << *obj.pointer << std::endl;

    return 0;
}

    1. First construct two A objects inside return_rvalue, and get the output of the two constructors

    2. After the function returns, it will generate a xvalue, which is referenced by the moving structure of A (A(A&&)), 
    thus extending the life cycle, and taking the pointer in the rvalue and saving it to obj. 
    In the middle, the pointer to the xvalue is set to nullptr, which prevents the memory area from being destroyed

  This avoids meaningless copy constructs and enhances performance. 

#include <iostream> // std::cout
#include <utility> // std::move
#include <vector> // std::vector
#include <string> // std::string

int main() 
{
    std::string str = "Hello world.";
    std::vector<std::string> v;

    // use push_back(const T&), copy
    v.push_back(str);

    // "str: Hello world."
    std::cout << "str: " << str << std::endl;

    // use push_back(const T&&),
    // no copy the string will be moved to vector,
    // and therefore std::move can reduce copy cost
    v.push_back(std::move(str));

    // str is empty now
    std::cout << "str: " << str << std::endl;
    return 0;
}

- Perfect forwarding

  The rvalue reference of a declaration is actually an lvalue. 
  This creates problems for us to parameterize (pass)

#include <iostream>
#include <utility>

void reference(int& v) 
{
    std::cout << "lvalue reference" << std::endl;
}

void reference(int&& v) 
{
    std::cout << "rvalue reference" << std::endl;
}

template <typename T>
void pass(T&& v) 
{
    std::cout << " normal param passing: ";

    // Since v is a reference variable, it always be an lvalue.
    reference(v);
}

int main() 
{
    std::cout << "rvalue pass:" << std::endl;
    pass(1);    // Even though value ifself is rvalue, v is reference value. So "void reference(int& v)" will be called

    std::cout << "lvalue pass:" << std::endl;
    int l = 1;
    pass(l);    // Successfully passed to "void reference(int& v)"

    reference(1);  // Successfully passed to "void reference(int&& v)"

    return 0;
}

  In traditional C++, it is impossible to continue reference a reference type.

  Now it is possible to reference references. But follow the rule below

  Function parameter type | Argument parameter type | Post-derivation function parameter type
            T&            |       lvalue ref        |                   T&
            T&            |       rvalue ref        |                   T&
            T&&           |       lvalue ref        |                   T&
            T&&           |       rvalue ref        |                   T&&

  Therefore, the use of T&& in a template function may not be able to make an rvalue reference, 
  and when a lvalue is passed, a reference of this function will be derived as an lvalue.

  No matter what type of reference the template parameter is, 
  the template parameter can be derived as a right reference type if and only if the argument type is a right reference.

  Perfect forwarding let us pass the parameters, keep the original parameter type

#include <iostream>
#include <utility>

void reference(int& v)
{
    std::cout << "lvalue reference" << std::endl;
}

void reference(int&& v)
{
    std::cout << "rvalue reference" << std::endl;
}

template<typename T>
void pass(T&& v)
{
    std::cout << "Normal Passing : ";
    reference(v);

    std::cout << "Move Passing : ";
    reference(std::move(v));

    std::cout << "Forward Passing : ";
    reference(std::forward<T>(v));

    std::cout << "static_cast<T&&> param passing: ";
    reference(static_cast<T&&>(v));
}

int main() {
    std::cout << "rvalue pass:" << std::endl;
    pass(1);

    std::cout << "lvalue pass:" << std::endl;
    int l = 1;
    pass(l);

    return 0;
}

  std::forward is the same as std::move, and nothing is done. 

  std::move simply converts the lvalue to the rvalue. 

  std::forward is just a simple conversion of the parameters. 

  std::forward<T>(v) is the same as static_cast<T&&>(v).

template<typename _Tp>
constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type& __t) noexcept
{
  return static_cast<_Tp&&>(__t); 
}

template<typename _Tp>
constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
{
  static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
  " substituting _Tp is an lvalue reference type");

  return static_cast<_Tp&&>(__t);
}

  The function of std::remove_reference is to eliminate references in the type.

  std::is_lvalue_reference is used to check if the type derivation is correct.
